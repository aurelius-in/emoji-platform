<!DOCTYPE html>
<html>
<head>
  <title>Emoji Platformer</title>
  <style>
    body { margin: 0; padding: 0; }
    canvas { border: 4px solid black; }
  </style>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
</head>
<body>
  <canvas id="gameCanvas" width="3200" height="1440"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let gameState = 'selectCharacter', playerEmoji = null, scrollX = 0;
    let player = { x: 50, y: 960, width: 50, height: 50, vx: 10, vy: 0, gravity: 0.5, jump: -10, grounded: false, jumping: false };
    let hills = [{x: 0, y: 960}, {x: 500, y: 960}];
    let animals = [];
    let touchStartX, touchStartY, touchEndX, touchEndY;
    let bgHills = [{x: 0, y: 960}, {x: 500, y: 960}];
    let bgEmojiList = ["ðŸŒ³", "ðŸŒ²", "ðŸŒ´", "ðŸŒµ", "ðŸŒ¾", "ðŸŒ¿", "ðŸ€", "ðŸ", "ðŸ‚", "ðŸƒ"];
    let lastBgEmojiSpawnTime = new Date().getTime();
    let bgEmojis = [];
    const tinyAnimals = ["ðŸž", "ðŸ›", "ðŸ¦—", "ðŸœ", "ðŸŒ", "ðŸ¦Ÿ", "ðŸ€", "ðŸ", "ðŸª°"];
    const smallAnimals = ["ðŸˆ", "ðŸ’", "ðŸ•", "ðŸ¦‚", "ðŸ¦”", "ðŸ¦¨", "ðŸ¢", "ðŸ¦†", "ðŸ¦¤", "ðŸ¦", "ðŸ“", "ðŸˆâ€â¬›", "ðŸ©", "ðŸ¦«", "ðŸ¿", "ðŸ¦¡", "ðŸª¿", "ðŸ‡"];
    const bigAnimals = ["ðŸ¦", "ðŸ¦˜", "ðŸ¦“", "ðŸ–", "ðŸƒ", "ðŸ‚", "ðŸ¦", "ðŸ", "ðŸª", "ðŸ«", "ðŸ†", "ðŸ…", "ðŸ¦›", "ðŸ¦Œ", "ðŸ«", "ðŸ¦¦", "ðŸ", "ðŸ¦™", "ðŸ‘"];
    const hugeAnimals = ["ðŸ˜", "ðŸ¦£", "ðŸ™"];
    const tallAnimals = ["ðŸ¦’", "ðŸ¦–", "ðŸ¦•"];
    const allAnimals = [...tinyAnimals, ...smallAnimals, ...bigAnimals, ...hugeAnimals, ...tallAnimals];
    let animalSpawnCounter = 0; // Added counter for animal spawn
    let bgEmojiSpawnCounter = 0; // Added counter for background emoji spawn

    // Event listeners for touchstart and touchend
    canvas.addEventListener("touchstart", function(e) {
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      // Character selection logic
      if (gameState === 'selectCharacter') {
        if (touch.clientX >= 600 && touch.clientX <= 900 && touch.clientY >= 400 && touch.clientY <= 700) {
          playerEmoji = "ðŸ‘¨â€ðŸ¦½";
          gameState = 'play';
        } else if (touch.clientX >= 1400 && touch.clientX <= 1700 && touch.clientY >= 400 && touch.clientY <= 700) {
          playerEmoji = "ðŸ‘©â€ðŸ¦½";
          gameState = 'play';
        }
      }
    });

    canvas.addEventListener("touchend", function(e) {
      e.preventDefault();
      const touch = e.changedTouches[0];
      touchEndX = touch.clientX;
      touchEndY = touch.clientY;
      // Movement logic
      if (gameState !== 'selectCharacter') {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (deltaX > 0) {
            player.x += 50;
          } else {
            player.x -= 50;
          }
        } else {
          if (deltaY < 0 && player.grounded) {
            player.vy = player.jump;
            player.grounded = false;
            player.jumping = true;
          }
        }
      }
    });

    const generateHill = () => {
      const lastHill = hills[hills.length - 1];
      const newHill = {
        x: lastHill.x + Math.floor(Math.random() * 200) + 100,
        y: Math.min(canvas.height - 50, Math.max(50, lastHill.y + Math.floor(Math.random() * 400) - 200))
      };
      hills.push(newHill);
      generateAnimal(newHill);
      animalSpawnCounter++;
      if (animalSpawnCounter >= 4) { // Generate animal every 4th hill
        generateAnimal(newHill);
        animalSpawnCounter = 0;
      }
    };

    const generateAnimal = (hill) => {
      const animalEmoji = allAnimals[Math.floor(Math.random() * allAnimals.length)];
      const animalSize = tinyAnimals.includes(animalEmoji) ? 'tiny' : smallAnimals.includes(animalEmoji) ? 'small' : bigAnimals.includes(animalEmoji) ? 'big' : 'huge';
      const newAnimal = { emoji: animalEmoji, x: hill.x, y: hill.y - 50, size: animalSize };
      animals.push(newAnimal);
    };

    for (let i = 0; i < 20; i++) generateHill();

    const draw = () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (gameState === 'selectCharacter') {
    // Save the current context state
    ctx.save();

    // Translate to the emoji's position
    ctx.translate(750, 700);

    // Flip the context horizontally
    ctx.scale(-1, 1);

    // Draw the flipped emoji
    ctx.font = "300px Arial";
    ctx.fillText("ðŸ‘©â€ðŸ¦½", -150, 0);

    // Restore the context to its original state
    ctx.restore();

    ctx.font = "300px Arial";
    ctx.fillText("or", 1000, 700);

    // Save the current context state
    ctx.save();

    // Translate to the emoji's position
    ctx.translate(1550, 700);

    // Flip the context horizontally
    ctx.scale(-1, 1);

    // Draw the flipped emoji
    ctx.font = "300px Arial";
    ctx.fillText("ðŸ‘¨â€ðŸ¦½", -150, 0);

    // Restore the context to its original state
    ctx.restore();
  } else {
    // Save the current context state
    ctx.save();

    // Translate to the player's position
    ctx.translate(player.x - scrollX + player.width / 2, player.y + player.height / 2);

    // Flip the context horizontally
    ctx.scale(-1, 1);

    // Draw the flipped emoji
    ctx.font = "144px Arial";
    ctx.fillText(playerEmoji, -player.width / 2, -player.height / 2);

    // Restore the context to its original state
    ctx.restore();

 // Draw background hills
        ctx.beginPath();
        ctx.moveTo(bgHills[0].x - scrollX, bgHills[0].y);
        bgHills.forEach((hill, index) => {
          if (index !== 0) {
            ctx.lineTo(hill.x - scrollX, hill.y);
          }
        });
        ctx.lineTo(canvas.width, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.closePath();
        ctx.fillStyle = "#D2B48C";
        ctx.fill();
        ctx.stroke();

    // Generate and draw background emojis
        bgEmojiSpawnCounter++;
        const currentTime = new Date().getTime();
        if (bgEmojiSpawnCounter >= 4 && currentTime - lastBgEmojiSpawnTime >= Math.random() * 250 + 250) {
          const bgEmoji = bgEmojiList[Math.floor(Math.random() * bgEmojiList.length)];
          const size = Math.floor(Math.random() * 31) + 40;
          const newBgEmoji = { emoji: bgEmoji, x: player.x + canvas.width, y: bgHills[bgHills.length - 1].y - 50, size: size };
          bgEmojis.push(newBgEmoji);
          lastBgEmojiSpawnTime = currentTime;
          bgEmojiSpawnCounter = 0;
        }
        // ... (existing code remains unchanged)
      }
    };
       // Draw rounded hills
    ctx.beginPath();
    ctx.moveTo(hills[0].x - scrollX, hills[0].y);
    for (let i = 1; i < hills.length; i++) {
      const prevHill = hills[i - 1];
      const hill = hills[i];
      const midX = (prevHill.x + hill.x) / 2 - scrollX;
      const midY = (prevHill.y + hill.y) / 2;
      ctx.quadraticCurveTo(prevHill.x - scrollX, prevHill.y, midX, midY);
    }
    ctx.lineTo(hills[hills.length - 1].x - scrollX, hills[hills.length - 1].y);
    ctx.lineTo(canvas.width, canvas.height);
    ctx.lineTo(0, canvas.height);
    ctx.closePath();
    ctx.fillStyle = "#8B4513"; // Brown color for dirt
    ctx.fill();
    ctx.stroke();

    // Draw grass on hills
    hills.forEach((hill, index) => {
      for (let i = 0; i < 10; i++) {
        const x = hill.x - scrollX + Math.random() * 50 - 25;
        const y = hill.y + Math.random() * 5 - 2.5;
        ctx.strokeStyle = `rgb(${Math.floor(Math.random() * 56) + 100}, ${Math.floor(Math.random() * 56) + 100}, 0)`;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y - 5);
        ctx.stroke();
      }
    });

    // Draw animals
    animals.forEach(animal => {
      ctx.font = animal.size === 'tiny' ? "50px Arial" : animal.size === 'small' ? "100px Arial" : animal.size === 'big' ? "200px Arial" : animal.size === 'huge' ? "300px Arial" : "450px Arial";
      ctx.fillText(animal.emoji, animal.x - scrollX, animal.y);
    });
  }
};

const update = () => {
  if (gameState !== 'selectCharacter') {
    player.y += player.vy;
    player.vy += player.gravity;
    player.grounded = false;

    let prevHill = null;
    let slope = 0;

    // Collision detection with hills
    hills.forEach((hill, index) => {
      if (index > 0) {
        prevHill = hills[index - 1];
        slope = (hill.y - prevHill.y) / (hill.x - prevHill.x);
        if (player.x >= prevHill.x && player.x <= hill.x) {
          const expectedY = slope * (player.x - prevHill.x) + prevHill.y;
          if (player.y >= expectedY) {
            player.y = expectedY;
            player.vy = 0;
            player.grounded = true;
            player.jumping = false;

            // Apply enhanced gravity based on slope
            if (slope > 0) {
              player.x += slope * 8;  // Increased multiplier for more gravity
            } else {
              player.x += slope * 4;  // Some momentum to go up the hill
            }
          }
        }
      }
    });

    if (player.x > hills[hills.length - 2].x) {
      generateHill();
    }

    scrollX = player.x - canvas.width / 2;
  }
};

    const gameLoop = () => {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    };

    gameLoop();
  </script>
</body>
</html>
